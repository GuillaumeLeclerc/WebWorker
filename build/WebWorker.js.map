{"version":3,"file":"WebWorker.js","sources":["../src/WebWorker.js"],"names":["WebWorker","script","that","this","booked","eventsRegistered","eventQueue","nextTaskId","runningTask","EventEmitter","call","state","worker","Worker","libPath","taskQueue","sendMessage","evtName","data","out","push","postMessage","newTaskId","load","console","log","workersPath","resetEvents","ready","isReady","emitEvent","dequeueTask","finished","messageData","error","JSON","stringify","progress","registerMethods","methodNames","mIndex","method","doWork","bind","eventsRegisteredCallback","processQueueEvent","terminate","length","event","shift","name","sendEventToTask","taskId","message","value","book","addEventListener","e","messageName","task","work","defered","progressCallback","methodName","id","addListener","addOnceListener","result","removeListener","resolve","reject","Q","defer","toReturn","promise","sendEvent","prototype","Object","create","constructor","WorkerPool","minSize","maxSize","workers","waitQueue","workerReadyCallback","freeWorker","resolved","methodAvailable","batchMethodName","doWorkBatch","createWorker","w","i","undefined","getWorker","args","arguments","then","apply","fail","jobs","promises","prom","all"],"mappings":"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","sourcesContent":["function WebWorker(script) {\n\t\"use strict\";\n\tvar that = this;\n\tvar booked = false;\n\tvar eventsRegistered = false;\n\tvar eventQueue = {};\n\tvar nextTaskId = 0;\n\tvar runningTask = -1;\n\n\tEventEmitter.call(that);\n\tthat.script = script || \"simulate.js\";\n\tthat.state = \"loading\";\n\tthat.worker = new Worker(WebWorker.libPath + \"workerCode.js\");\n\tthat.taskQueue = [];\n\n\tvar sendMessage = function (evtName, data) {\n\t\tvar out = [ evtName ];\n\t\tif (typeof data !== \"undefined\") { out.push(data);\n\t\t}\n\t\tthat.worker.postMessage(out);\n\t};\n\n\tvar newTaskId = function() {\n\t\treturn ++nextTaskId;\n\t};\n\n\tvar load = function() {\n\t\tconsole.log(\"PRELOAEDDED\");\n\t\tthat.state = \"preloaded\";\n\t\tsendMessage(\"load\", WebWorker.workersPath + that.script);\n\t};\n\n\tvar resetEvents = function() {\n\t\teventsRegistered = false;\n\t};\n\n\tvar ready = function() {\n\t\tconsole.log(\"Worker ready\");\n\t\tthat.state = \"ready\";\n\t\trunningTask = -1;\n\t\tif (that.isReady()) {\n\t\t\tthat.emitEvent(\"ready\", [that]);\n\t\t} else {\n\t\t\tdequeueTask();\n\t\t}\n\t};\n\n\tvar finished = function(messageData) {\n\t\tthat.emitEvent(\"resultAvailable\", [messageData]);\n\t\tresetEvents();\n\t\tready();\n\t};\n\n\tvar error = function(error) {\n\t\tif (that.state !== \"busy\") {\n\t\t\tconsole.log(\"Error\", JSON.stringify(error));\n\t\t\tthat.state = \"error\";\n\t\t\tthat.emitEvent(\"error\", [error]);\n\t\t} else {\n\t\t\tthat.emitEvent(\"runError\", [error]);\n\t\t\tresetEvents();\n\t\t\tready();\n\t\t}\n\t};\n\n\tvar progress = function(data) {\n\t\tthat.emitEvent(\"progress\", [data]);\n\t};\n\n\tvar registerMethods = function(methodNames) {\n\t\tfor (var mIndex in methodNames) {\n\t\t\tvar method = methodNames[mIndex];\n\t\t\t// we make sure we do not override a worker method\n\t\t\tif (typeof that[method] === \"undefined\") {\n\t\t\t\tthat.emitEvent(\"methodAvailable\", [method]);\n\t\t\t\tthat[method] = that.doWork.bind(that, method);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar eventsRegisteredCallback = function() {\n\t\teventsRegistered = true;\n\t\tprocessQueueEvent();\n\t};\n\n\tthat.terminate = function () {\n\t\tthat.worker.terminate();\n\t\tthat.state = \"terminated\";\n\t};\n\n\tvar processQueueEvent = function() {\n\t\twhile (eventsRegistered &&  eventQueue[runningTask] && eventQueue[runningTask].length > 0) {\n\t\t\tvar event = eventQueue[runningTask].shift();\n\t\t\tsendMessage(event.name, event.data);\n\t\t}\t\n\t};\n\n\tvar sendEventToTask = function(taskId, message, value) {\n\t\teventQueue[taskId] = eventQueue[taskId] || [];\n\t\teventQueue[taskId].push({\n\t\t\tname : \"custom-\" + message,\n\t\t\tdata : value\n\t\t});\n\t\tprocessQueueEvent();\n\t};\n\n\tthat.book = function() {\n\t\tbooked = true;\n\t};\n\n\tthat.isReady = function() {\n\t\treturn that.state === \"ready\" && that.taskQueue.length === 0 && !booked;\n\t};\n\n\tthat.worker.addEventListener(\"message\", function(e) {\n\t\tvar message = e.data;\n\t\tvar messageName = message[0];\n\t\tvar messageData = message[1];\n\t\tswitch (messageName) {\n\t\t\tcase \"error\" : \n\t\t\t\terror(messageData);\n\t\t\t\tbreak;\n\t\t\tcase \"preloaded\" : \n\t\t\t\tload();\n\t\t\t\tconsole.log(\"Loaded\");\n\t\t\t\tbreak;\n\t\t\tcase \"loaded\" :\n\t\t\t\t//registerMethods(messageData);\n\t\t\t\tready();\n\t\t\t\tbreak;\n\t\t\tcase \"startWorking\" :\n\t\t\t\tconsole.log(\"start working\");\n\t\t\t\tthat.state = \"busy\";\n\t\t\t\tbreak;\n\t\t\tcase \"progress\" :\n\t\t\t\tprogress(messageData);\n\t\t\t\tbreak;\n\t\t\tcase \"finishedWorking\" :\n\t\t\t\tconsole.log(\"finished working\");\n\t\t\t\tfinished(messageData);\n\t\t\t   break;\n\t\t\tcase \"eventsRegistered\" : \n\t\t\t   eventsRegisteredCallback();\n\t\t\t   break;\n\t\t\tdefault :\n\t\t\t   that.emitEvent(messageName, [messageData]);\n\t\t}\n\t});\n\n\tvar dequeueTask = function() {\n\n\t\tif (that.state !== \"ready\" || that.taskQueue.length === 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tthat.state = \"busy\";\n\t\t}\n\n\t\tvar task = that.taskQueue.shift();\n\t\tvar work = task.work;\n\t\tvar defered = task.defered;\n\t\tvar progress = task.progressCallback;\n\t\tvar methodName = task.methodName;\n\t\tvar taskId = task.id;\n\n\n\t\trunningTask = taskId;\n\n\t\tsendMessage(\"work\", [methodName, work]);\n\n\t\tif (typeof progress === \"function\") {\n\t\t\tthat.addListener(\"progress\", progress);\n\t\t}\n\n\t\tthat.addOnceListener(\"resultAvailable\", function(result) {\n\t\t\tif (typeof progress === \"function\") {\n\t\t\t\tthat.removeListener(\"progress\", progress);\n\t\t\t}\n\t\t\tdefered.resolve(result);\n\t\t});\n\t\tthat.addOnceListener(\"runError\", function(error) {\n\t\t\tthat.removeListener(\"progress\", progress);\n\t\t\tdefered.reject(error);\n\t\t});\n\t};\n\n\tthat.doWork = function(methodName, work, progressCallback) {\n\t\tbooked = false;\n\t\tvar taskId = newTaskId();\n\t\tvar defered = Q.defer();\n\n\t\tvar task = {\n\t\t\tid : taskId,\n\t\t\tmethodName : methodName,\n\t\t\twork : work,\n\t\t\tprogressCallback : progressCallback,\n\t\t\tdefered : defered\n\t\t};\n\n\t\tthat.taskQueue.push(task);\n\t\tdequeueTask();\n\n\t\tvar toReturn = defered.promise;\n\t\ttoReturn.sendEvent = function(name, message) {\n\t\t\tconsole.log(message, work, taskId);\n\t\t\tsendEventToTask(taskId, name, message);\n\t\t};\n\n\t\treturn toReturn;\n\t};\n}\n\nWebWorker.libPath = \"workers/\";\nWebWorker.workersPath = \"workers/\";\n\nWebWorker.prototype = Object.create(EventEmitter.prototype);\nWebWorker.prototype.constructor = WebWorker;\n\nfunction WorkerPool(minSize, maxSize, script) {\n\t\"use strict\";\n\tvar that = this;\n\n\tif (typeof minSize !== \"number\" ||\n\t\t\ttypeof maxSize !== \"number\" ||\n\t\t\ttypeof script !== \"string\"){\n\t\tthrow \"Invalid arguments\";\n\t}\n\n\t\n\tvar workers = [];\n\n\tthat.workers = workers;\n\n\tvar waitQueue = [];\n\n\tvar workerReadyCallback = function() {\n\t\twhile(waitQueue.length > 0 && freeWorker()) {\n\t\t\tvar resolved = waitQueue.shift();\n\t\t\tvar worker = freeWorker();\n\t\t\tworker.book();\n\t\t\tresolved.resolve(worker);\n\t\t}\n\t};\n\t\n\tvar methodAvailable = function(methodName) {\n\t\tvar batchMethodName = methodName + \"Batch\";\n\t\t// we make sure we are not overwriting an existing method\n\t\tif (typeof that[methodName] === \"undefined\") {\n\t\t\tthat[methodName] = that.doWork.bind(this, methodName);\n\t\t}\n\t\t// we make sure we are not overwriting an existing method\n\t\tif (typeof that[batchMethodName] === \"undefined\") {\n\t\t\tthat[batchMethodName] = that.doWorkBatch.bind(this, methodName);\n\t\t}\n\t};\n\n\tvar createWorker = function() {\n\t\tvar w = new WebWorker(script);\n\t\tif (w) { //only if the worker was created\n\t\t\tw.addListener(\"ready\", workerReadyCallback);\n\t\t\tw.addListener(\"methodAvailable\", methodAvailable);\n\t\t\tworkers.push(w);\n\t\t}\n\t\treturn w;\n\t};\n\n\tvar freeWorker = function() {\n\t\tfor (var i in workers) {\n\t\t\tif (workers[i].isReady()) {\n\t\t\t\tconsole.log(\"assigning \" + i);\n\t\t\t\treturn workers[i];\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n\n\tvar getWorker = function() {\n\t\tvar defered = Q.defer();\n\t\tvar worker = freeWorker();\n\n\t\tif (worker) {\n\t\t\tworker.book();\n\t\t\tdefered.resolve(worker);\n\t\t\tconsole.log(\"using a free worker\");\n\t\t\treturn defered.promise;\n\t\t} else if (workers.length < maxSize) {\n\t\t\tconsole.log(\"dynamically creating a new worker\");\n\t\t\tworker = createWorker();\n\t\t\tif (worker) {\n\t\t\t\tworker.book();\n\t\t\t\tdefered.resolve(worker);\n\t\t\t\treturn defered.promise;\n\t\t\t} else {\n\t\t\t\tconsole.log(\"unable to create more workers\");\n\t\t\t}\n\t\t}\n\t\tconsole.log(\"waiting a worker to be ready\");\n\t\twaitQueue.push(defered);\n\t\treturn defered.promise;\n\t};\n\n\tfor (var i = 0 ; i < minSize ; ++i) {\n\t\tcreateWorker();\n\t}\n\n\tthat.terminate = function() {\n\t\tfor (var i in workers) {\n\t\t\tworkers[i].terminate();\n\t\t}\n\t};\n\n\t that.doWork = function() {\n\t\tvar args = arguments;\n\t\tvar eventQueue = [];\n\t\tvar toReturn = getWorker().then(function(worker) {\n\t\t\tvar promise = worker.doWork.apply(worker, args);\n\t\t\twhile (eventQueue.length > 0) {\n\t\t\t\tvar event = eventQueue.shift();\n\t\t\t\tpromise.sendEvent(event.name, event.data);\n\t\t\t}\n\t\t\treturn promise;\n\t\t}).fail(function(error) {\n\t\t\tthrow error;\n\t\t});\n\n\t\ttoReturn.sendEvent = function(name , data) {\n\t\t\teventQueue.push({\n\t\t\t\tname : name,\n\t\t\t\tdata : data\n\t\t\t});\n\t\t};\n\n\t\treturn toReturn;\n\t};\n\n\tthat.doWorkBatch = function(methodName, jobs) {\n\t\tvar promises = [];\n\t\tfor (var i in jobs) {\n\t\t\tvar prom = that.doWork(methodName, jobs[i]);\n\t\t\tpromises.push(prom);\n\t\t}\n\t\treturn Q.all(promises);\n\t};\n}\n"]}