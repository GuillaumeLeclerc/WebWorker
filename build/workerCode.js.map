{"version":3,"file":"workerCode.js","sources":["../src/workerCode.js"],"names":["sendMessage","evtName","data","out","push","postMessage","defined","eventListeners","define","dependencies","definition","i","importScripts","Error","availableMethods","j","replace","loadedCallback","loadSync","error","load","handler","message","e","name","work","params","methodName","methodNameSync","args","progressCallback","progress","registerEvents","events","doneCallback","result","self","onmessage","messageName"],"mappings":"AAAA,SAASA,YAAYC,SAASC;IAC7B;IACA,IAAIC,QAAQF;IACZ,WAAWC,SAAS,aAAa;QAChCC,IAAIC,KAAKF;;IAEVG,YAAYF;;;AAGb,IAAIG,UAAU;;AAEd,IAAIC;;AAEJ,SAASC,OAAOC,cAAcC;IAC7B;IACA,IAAIJ,YAAY,MAAM;QACrB,OAAON,YAAY,SAAS;;IAE7B,KAAK,IAAIW,KAAKF,cAAc;QAC3BG,cAAcH,aAAaE;;IAE5B,KAAKD,qBAAqBA,eAAe,UAAU;QAClDV,YAAY,SAAS,IAAIa,MAAM;;IAGhC,IAAIC;IAEJ,KAAK,IAAIC,KAAKL,YAAY;QACzB,IAAIK,MAAM,UAAUA,MAAM,YAAY;YACrCA,IAAIA,EAAEC,QAAQ,SAAS;YACvBF,iBAAiBV,KAAKW;;;IAIxB,IAAIE,iBAAiB;QACpBjB,YAAY,UAAUc;;IAGvB,IAAIJ,WAAWQ,mBAAmBR,WAAWQ,aAAa,YAAY;QACrE;YACCR,WAAWQ;YACXD;UACC,OAAOE;YACRnB,YAAY,SAASmB;;WAEhB,IAAIT,WAAWU,eAAeV,WAAWU,SAAS,YAAY;QACpEV,WAAWU,KAAK,SAASD;YACxB,IAAIA,OAAO;gBACVnB,YAAY,SAASmB;mBACf;gBACNF;;;WAGI;QACNA;;IAGDX,UAAUI;;;AAGX,IAAIW;IACHD,MAAO,SAASE;QACf;QACA;YACCV,cAAcU;UACb,OAAOC;YACRvB,YAAY;gBACXwB,MAAOD,EAAEC;gBACTF,SAAUC,EAAED;;;;IAKfG,MAAO,SAASC;QACf;QAEA,IAAIC,aAAaD,OAAO;QACxB,IAAIE,iBAAiBD,aAAa;QAClC,IAAIE,OAAOH,OAAO;QAElB,IAAII,mBAAmB,SAASC;YAC/B/B,YAAY,YAAY+B;;QAGzB,IAAIC,iBAAiB,SAASC;YAC7B,KAAK,IAAItB,KAAKsB,QAAQ;gBACrB,WAAWA,OAAOtB,OAAO,YAAY;oBACpCJ,eAAe,YAAUI,KAAKsB,OAAOtB;;;YAGvCX,YAAY;;QAGb,IAAIkC,eAAe,SAASC;YAE3B5B;YACA,OAAOP,YAAY,mBAAmBmC;;QAGvCnC,YAAY;QACZ,IAAIM,QAAQsB,0BAA0BtB,QAAQsB,oBAAoB,YAAY;YAC7E;gBACC,IAAIO,SAAS7B,QAAQsB,gBAAgBC,MAAMC,kBAAkBE;gBAC7DE,aAAaC;cACZ,OAAOZ;gBACR,OAAOvB,YAAY,SAASuB;;eAEvB,IAAIjB,QAAQqB,sBAAsBrB,QAAQqB,gBAAgB,YAAY;YAC5ErB,QAAQqB,YAAYE,MAAM,SAASV,OAAOgB;gBACzC,IAAIhB,OAAO;oBACV,OAAOnB,YAAY,SAASmB;uBACtB;oBACNe,aAAaC;;eAEZL,kBAAkBE;eACf;YACN,OAAOhC,YAAY,SAAS2B,aAAa,UAAUC,iBAAiB;;;;;AAKvEQ,KAAKC,YAAY,SAASd;IACzB;IACA,IAAID,UAAUC,EAAErB;IAChB,IAAIoC,cAAchB,QAAQ;IAC1B,IAAIpB,OAAOoB,QAAQ;IACnB,WAAWD,QAAQiB,iBAAiB,YAAY;QAC/CjB,QAAQiB,aAAapC;WACf,WAAWK,eAAe+B,iBAAiB,YAAY;QAC7D/B,eAAe+B,aAAapC;;;;AAI9BF,YAAY","sourcesContent":["function sendMessage(evtName, data) {\n\t\"use strict\";\n\tvar out = [ evtName ];\n\tif (typeof data !== \"undefined\") {\n\t\tout.push(data);\n\t}\n\tpostMessage(out);\n}\n\nvar defined = null;\n\nvar eventListeners = {};\n\nfunction define(dependencies, definition) {\n\t\"use strict\";\n\tif (defined !== null) {\n\t\treturn sendMessage(\"error\", \"You can define your worker only once !\");\n\t}\n\tfor (var i in dependencies) {\n\t\timportScripts(dependencies[i]);\n\t}\n\tif (!definition || typeof definition !== \"object\") {\n\t\tsendMessage(\"error\", new Error(\"The second argument of the define function should be an object\"));\n\t}\n\n\tvar availableMethods = [];\n\n\tfor (var j in definition) {\n\t\tif (j !== \"load\" && j !== \"loadSync\") { //we don't want to expose the loading methods\n\t\t\tj = j.replace(/Sync$/, \"\");\n\t\t\tavailableMethods.push(j);\n\t\t}\n\t}\n\n\tvar loadedCallback = function() {\n\t\tsendMessage(\"loaded\", availableMethods);\n\t};\n\n\tif (definition.loadSync && typeof definition.loadSync === \"function\") {\n\t\ttry {\n\t\t\tdefinition.loadSync();\n\t\t\tloadedCallback();\n\t\t} catch (error) {\n\t\t\tsendMessage(\"error\", error);\n\t\t}\n\t} else if (definition.load && typeof definition.load === \"function\") {\n\t\tdefinition.load(function(error) {\n\t\t\tif (error) {\n\t\t\t\tsendMessage(\"error\", error);\n\t\t\t} else {\n\t\t\t\tloadedCallback();\n\t\t\t}\n\t\t});\n\t} else {\n\t\tloadedCallback();\n\t}\n\n\tdefined = definition;\n}\n\nvar handler = {\n\tload : function(message) {\n\t\t\"use strict\";\n\t\ttry {\n\t\t\timportScripts(message);\n\t\t} catch (e) {\n\t\t\tsendMessage(\"error\", {\n\t\t\t\tname : e.name,\n\t\t\t\tmessage : e.message\n\t\t\t});\n\t\t}\n\t},\n\n\twork : function(params) {\n\t\t\"use strict\";\n\n\t\tvar methodName = params[0];\n\t\tvar methodNameSync = methodName + \"Sync\";\n\t\tvar args = params[1];\n\t\t\n\t\tvar progressCallback = function(progress) {\n\t\t\tsendMessage(\"progress\", progress);\n\t\t};\n\n\t\tvar registerEvents = function(events) {\n\t\t\tfor (var i in events) {\n\t\t\t\tif (typeof events[i] === \"function\") {\n\t\t\t\t\teventListeners[\"custom-\"+i] = events[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsendMessage(\"eventsRegistered\");\n\t\t};\n\n\t\tvar doneCallback = function(result) {\n\t\t\t// we reset listeners because there might be a new job\n\t\t\teventListeners = {};\n\t\t\treturn sendMessage(\"finishedWorking\", result);\n\t\t};\n\n\t\tsendMessage(\"startWorking\");\n\t\tif (defined[methodNameSync] && typeof defined[methodNameSync] === \"function\") {\n\t\t\ttry {\n\t\t\t\tvar result = defined[methodNameSync](args, progressCallback, registerEvents);\n\t\t\t\tdoneCallback(result);\n\t\t\t} catch (e) {\n\t\t\t\treturn sendMessage(\"error\", e);\n\t\t\t}\n\t\t} else if (defined[methodName] && typeof defined[methodName] === \"function\") {\n\t\t\tdefined[methodName](args, function(error, result) {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn sendMessage(\"error\", error);\n\t\t\t\t} else {\n\t\t\t\t\tdoneCallback(result);\n\t\t\t\t}\n\t\t\t}, progressCallback, registerEvents);\n\t\t} else {\n\t\t\treturn sendMessage(\"error\", methodName + \" and \" + methodNameSync + \" are not available in the worker\");\n\t\t}\n\t}\n};\n\nself.onmessage = function(e) {\n\t\"use strict\";\n\tvar message = e.data;\n\tvar messageName = message[0];\n\tvar data = message[1];\n\tif (typeof handler[messageName] === \"function\") {\n\t\thandler[messageName](data);\n\t} else if (typeof eventListeners[messageName] === \"function\") {\n\t\teventListeners[messageName](data);\n\t}\n};\n\nsendMessage(\"preloaded\");\n"]}